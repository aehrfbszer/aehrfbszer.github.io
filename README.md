# js原型链的一种解释

js原型，可以理解为模板，就像是一块印刷版，它们的用途类似，当你使用时，是用这块板去印刷一页新的书，然后对印刷出来的书随意修改。
印刷版正常是不应该动它的，但如果你想动它也可以。
这个印刷版是实时的，就像是光线穿过这块镂空印刷版，投影下来的就是每一个新书页。除非你在新书页上覆盖了新的文字（普通文字）去遮盖来自印刷版的投影，否则投影会随印刷版自身文字改变而实时改变，所以正常不应该动印刷版自身。

## 模板的定义：  
- *一个名称*
- *一个模板内容*
- *一个模板制造工艺(该怎么去造)*

使用模板：const some =  new Object();
new告诉你进行模板制造，造出新的一页纸，
- 模板的名称叫 Object，
- 模板里面的内容是 Object.prototype（像光影的实时投射的投影源） ，
- 模板的制造工艺(怎么去造)是构造函数，就是Object这个函数。


函数想变成一个模板，要满足上面3个条件，所以需要一个普通函数，
- 普通函数有名称；
- 普通函数是一个函数，函数里面的具体逻辑是制造工艺；（函数可以接受0或多个输入，返回或不返回输出）
- 普通函数没有模板内容，但你可以加。

模板内容是光影的实时映射，制造工艺(构造函数)里几乎都会有一些逻辑，这些逻辑打印出的文字就不再是光影的实时映射了，而是每张纸上的普通文字，不是光影文字。

如果全是光影文字，那么每张纸没有意义，不去改它(写上普通文字)，那就是只模板内容的映射，每张纸没有区别。但印那么多纸，就是用来写的，写上普通文字，每张纸就有了区别，每张纸上普通文字不同，记录的内容不同。构造函数的作用就是在每张纸上预设一些普通文字(可以根据构造函数不同的输入，预设一些不同的普通文字)。

光影文字在每张纸上无法修改，只能用普通文字遮蔽，想改就要去改模板内容，改了就影响所有被投射的光影文字。每张纸上修改各自的普通文字，互相之前不会产生任何影响。
所以模板内容应该放通用的特性，正常也不应该改动它。

原型链继承就像光影的映射，投影源是“模板内容”（prototype），光影映射可以多次进行。
原型链查找就是先查看最后纸张的普通文字，没有普通文字，就去查找光影文字(投影源)，投影源本身可以有普通文字和光影文字，还是先找普通文字，找不到继续找光影文字，找下一个投影源，最后的投影源是null，表示没有其他源头了。

存在光影文字，说明存在投影源（模板内容）。
真正的第一个投影源，说明它之上再无源头，那么，这个模板内容里面都是普通文字。 Object就是一个根投影源，名称叫Object，是一个构造函数，模板内容是 Object.prototype。

现在有一个二级投影源（根投影源投出来的一页纸），同时也是一张纸，叫它“老纸”，它会有来自根投影源的光影文字，还有一些自己的普通文字(也可以没有)，这个二级投影源投射出一张新的纸，叫它“新纸”。
这张新纸上再写一些普通文字。现在在这张新纸上找文字，先是找普通文字，有就找到，没就找光影源（二级投影源，老纸）；先找二级投影源（老纸）普通文字，如果没有普通文字，就继续找光影文字（根光影源），根光影源（根纸）按照定义来说，只有普通文字，还是没找到，那就是不存在。

# rust send sync
基本类型存在栈上，复制成本非常低。但实际编程中一定会需要复杂结构体，复杂数据存储于某个对象。对于复制这一定义，对应 Clone 这个trait。所有想能够复制的数据结构，都要实现这个Clone。然后，对于复制成本极低的数据结构（并不一定要基本数据类型），定义了 Copy 这个trait，要实现copy需要先实现clone，在手动调用复制的行为（调用clone方法）上，两种无差别，copy 这个trait里面没有内容，调用的就是clone的方法。注：具体的底层实现不一定这样，我只是表述我的逻辑。

clone于copy的区别在于，copy这个trait无法被手动调用，只要在一个变量名称对应的数据，变换到另一个变量名称时，自动调用了copy行为，如果这个数据类型未实现copy trait，那么就是进行了move行为。

move行为发生后，一个数据的新旧两个变量名，旧的失去了存在的意义，对旧的进行任何有意义操作，都是报错。新变量名是数据的新所有者。在copy行为下，新旧二者同时存在，是两个独立的存在，两份独立数据，互不干扰，各自可独立修改。

但正常的逻辑，对于某一个数据源，都是会进行多次操作，可能是查看数据然后继续分支逻辑，可能是查看并修改数据。反正查看是非常频繁的事。如果数据只能move，那么应该是写不了正常的代码逻辑了。然后，就有了引用（指针）的概念，指针是一个普通的基本类型 usize ，根据操作系统不同，有不同大小，例如64位系统对于u64。所谓指针（引用），就是对应数据源的地址编号。

一般来说，copy/move行为发生，那就是统一认为在另一个内存地址得到了一份新数据。（实际上copy是这样的；变量名其实就是指针，move其实是数据地址不变，搞了一个新的变量名/指针）这样认为是为了减少心智负担，rust没有gc，确保数据源在被使用的上下文中切实存在，所有的引用可以切实在 上下文/周围 找到数据源。如果不做这种假设，move了几十次，存在几十个来源不同变量名的引用，虽然对应同一个地址的数据源，但非人类可读，可能几百行代码，已经分不清来源是谁了。

为了确保在无gc的情况下，能在附件上下文找到来源，就有生命周期的概念。如果是一个独立完整不依赖其他数据的数据源，它不需要生命周期，生命周期就是它生到它死。现在一个引用指向某个数据源，为了能切实找到对应数据，那么引用的生命长度是：引用产生到引用废弃/数据源死亡。引用产生一定在数据源产生之后，也必须消亡于数据源消失之前或同一时刻。（但是引用可以单独作为一个可变的存在usize，可以指向不同数据源，所以不一定绑死一个数据源的生命周期，但这只是可变mut的情况，rust默认不可变）

现在是多线程的情况：几乎所有基本数据都可以在线程之间移动。所谓多线程，和cpu的能力有关，现代多核cpu，能做通用计算，但每个单独cpu都是相对独立的，每个cpu都有处理能力，也都有自己的数据/缓存。没有绝对的主次，最早的线程就是一个cpu对应一个线程。普通程序都是运行在一个线程/主线程上，到了多线程代码部分，由于数据是相对隔离的，并且线程之间也是消亡时间不等的，有的早消亡，有的晚。直接将 数据源/所有权 抛给另一个线程，这叫做 send，对于原线程，抛出去的数据源，生命周期就结束了。

我们往往不需要复制，因为复杂数据的复制是耗时/浪费资源的，所以某个变量（不管是数据源还是引用）的引用在不同线程中共享（读取数据/同步数据）的能力，就叫sync。某个变量是sync，就是该变量的引用（usize）是可复制且可传播到不同线程的。
所以存在某个 T ，其引用 &T 是send，那么 T 是 sync。

# rust是无gc的，所谓无gc且不像C++一样需要手动释放，那么就意味着rust是实时gc的，即绝大多数变量在超出使用范围后被销毁（在使用范围末端drop了）。要记住绝大多数变量是实时drop的！
编译器会做代码优化，写了3步的操作，会给你优化到一步完成。cpu会分支预测，乱序执行，猜测下一步做什么，提前做，只要最后的结果是正确的，代码执行顺序不重要。这些都是在单线程的时候，全是好处的优化。

当多线程的时候，会不可避免的遇到数据的共享与共享数据的互操作问题。当代码执行与逻辑判断的相关变量存在另一个线程上时，你需要的变量，状态变化不是预想的顺序，你针对这个数据的预想处理逻辑根本就无法适配了。

## 为了多线程的逻辑，当一种数据能在线程之间互相随意传递时，先把这种能力叫做send。到底什么算send呢？

- 不变的数据符合send吗：首先，一种不可变的数据是完美符合的，不变的数据只有两种状态，未创建与创建之后，创建之后在无数线程中互相传递也没问题，应为数据不变，每个线程里看到的数据都是一样的。但是当我们创建了无数不变的数据，在线程之中互相传递时，其实早就预设了一种立场，即这些数据是长久存在的。在有gc的编程语言里，当一个数据不被使用后会有复杂的机制，去查看这个数据是否无用了，然后无用数据回收。但是查看的操作是很耗资源的。在rust这种无gc的数据，如果你预设了数据在多线程里长久存在，那么在最后一个使用数据的线程中，怎样才能知晓这是该数据的生命终点呢？如果你在多线程中传递的数据，每一份都是独立的，每一份都是clone出来的，在每个线程结束后销毁自己的数据，这个性能怕是比有gc语言性能更差。所有rust的逻辑是绝大多数变量就地释放，一个不可变数据从a线程传到b线程，对应a来说，就算释放了，数据的真正释放由b线程负责，当你还想在a线程将这份数据再传给c线程是不可以的，除非你提前clone了一份数据。

- 现实中我们应该尽量避免深拷贝（clone），所以正常情况下，想要线程之间随意使用数据，且不过度消耗资源，最明显的答案是什么？是只保留一份不可变的数据，且保证其寿命足够长，且在最后不被使用了是应该回收的。rust是实时回收的，所以普通变量无法保证其寿命在多线程中足够长。但rust本身提供了满足这种条件的解决方案，那就是Arc，它的能力是指向（包裹）一份“不变的”数据，向外提供多个引用，以便外面多个线程读取数据。每向外提供一份引用，Arc内部有一个计数器就加一，如果某个线程结束了，那就drop了这个引用，Arc内部的计数器减一。在计数器归零前，任何一个线程都不负责数据的销毁，那些线程销毁的只是引用以及让计数器减一。知道Arc计数器归零了，其包裹的数据才到了销毁的时候。

- 现在已经有了一种方案来实现send，但是它太严格了，不变的数据限制太大了。往往只有可变的数据更有价值。但是，一旦数据在多线程中可变后，如果不加限制，共享数据的多线程互操作是无法解决的问题，就是说一定会出错。
- 如果这个多线程共享数据在任意时间点上，只有一个线程可以查看/修改，同一时刻的其他任何线程只能等待，等到可以得到数据，查看/修改的时间到来。那么在任意一个时刻下，唯一拥有数据的线程里，这一部分的代码逻辑里，这份数据是清晰的，可以对其进行读取或任何修改操作，在操作完成之后，这个线程会释放数据。毕竟还有很多其他线程在等，总不可能让其他线程到死也没碰过一次数据吧。这个能力叫它锁，保证任何时刻，数据只有一个修改者。rust也提供了，最常见的是Mutex，它保证读或写，在同一时刻只归属于一个线程。但其实，这个限制还可以放松，我们可以允许某个时刻多个线程一起读，但是无法写，那么在这个时刻，数据相当于不可变的，所有线程看到的数据都一样，如果此时你想写数据，是不可以的。那些读线程还在，并在处理逻辑，在运行代码，读线程认为数据为状态A，如果同时允许了一个写线程，你把数据改成了状态b，那么同一时刻，同一变量，怎么会允许又是a又是b，量子叠加态吗？只有所有读线程都不持有数据时，数据没有归属，那么在等待中的写线程可以拿到数据，进行写入修改。显然写线程只能是一个，不允许多个。同样显然，存在一个写线程活跃时，不能有任何其他读线程活跃，rust中对应的是RwLock。

