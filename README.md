# js原型链的一种解释

js原型，可以理解为模板，就像是一块印刷版，它们的用途类似，当你使用时，是用这块板去印刷一页新的书，然后对印刷出来的书随意修改。
印刷版正常是不应该动它的，但如果你想动它也可以。
这个印刷版是实时的，就像是光线穿过这块镂空印刷版，投影下来的就是每一个新书页。除非你在新书页上覆盖了新的文字（普通文字）去遮盖来自印刷版的投影，否则投影会随印刷版自身文字改变而实时改变，所以正常不应该动印刷版自身。

## 模板的定义：  
- *一个名称*
- *一个模板内容*
- *一个模板制造工艺(该怎么去造)*

使用模板：const some =  new Object();
new告诉你进行模板制造，造出新的一页纸，
- 模板的名称叫 Object，
- 模板里面的内容是 Object.prototype（像光影的实时投射的投影源） ，
- 模板的制造工艺(怎么去造)是构造函数，就是Object这个函数。


函数想变成一个模板，要满足上面3个条件，所以需要一个普通函数，
- 普通函数有名称；
- 普通函数是一个函数，函数里面的具体逻辑是制造工艺；（函数可以接受0或多个输入，返回或不返回输出）
- 普通函数没有模板内容，但你可以加。

模板内容是光影的实时映射，制造工艺(构造函数)里几乎都会有一些逻辑，这些逻辑打印出的文字就不再是光影的实时映射了，而是每张纸上的普通文字，不是光影文字。

如果全是光影文字，那么每张纸没有意义，不去改它(写上普通文字)，那就是只模板内容的映射，每张纸没有区别。但印那么多纸，就是用来写的，写上普通文字，每张纸就有了区别，每张纸上普通文字不同，记录的内容不同。构造函数的作用就是在每张纸上预设一些普通文字(可以根据构造函数不同的输入，预设一些不同的普通文字)。

光影文字在每张纸上无法修改，只能用普通文字遮蔽，想改就要去改模板内容，改了就影响所有被投射的光影文字。每张纸上修改各自的普通文字，互相之前不会产生任何影响。
所以模板内容应该放通用的特性，正常也不应该改动它。

原型链继承就像光影的映射，投影源是“模板内容”（prototype），光影映射可以多次进行。
原型链查找就是先查看最后纸张的普通文字，没有普通文字，就去查找光影文字(投影源)，投影源本身可以有普通文字和光影文字，还是先找普通文字，找不到继续找光影文字，找下一个投影源，最后的投影源是null，表示没有其他源头了。

存在光影文字，说明存在投影源（模板内容）。
真正的第一个投影源，说明它之上再无源头，那么，这个模板内容里面都是普通文字。 Object就是一个根投影源，名称叫Object，是一个构造函数，模板内容是 Object.prototype。

现在有一个二级投影源（根投影源投出来的一页纸），同时也是一张纸，叫它“老纸”，它会有来自根投影源的光影文字，还有一些自己的普通文字(也可以没有)，这个二级投影源投射出一张新的纸，叫它“新纸”。
这张新纸上再写一些普通文字。现在在这张新纸上找文字，先是找普通文字，有就找到，没就找光影源（二级投影源，老纸）；先找二级投影源（老纸）普通文字，如果没有普通文字，就继续找光影文字（根光影源），根光影源（根纸）按照定义来说，只有普通文字，还是没找到，那就是不存在。

# rust send sync
基本类型存在栈上，复制成本非常低。但实际编程中一定会需要复杂结构体，复杂数据存储于某个对象。对于复制这一定义，对应 Clone 这个trait。所有想能够复制的数据结构，都要实现这个Clone。然后，对于复制成本极低的数据结构（并不一定要基本数据类型），定义了 Copy 这个trait，要实现copy需要先实现clone，在手动调用复制的行为（调用clone方法）上，两种无差别，copy 这个trait里面没有内容，调用的就是clone的方法。注：具体的底层实现不一定这样，我只是表述我的逻辑。

clone于copy的区别在于，copy这个trait无法被手动调用，只要在一个变量名称对应的数据，变换到另一个变量名称时，自动调用了copy行为，如果这个数据类型未实现copy trait，那么就是进行了move行为。

move行为发生后，一个数据的新旧两个变量名，旧的失去了存在的意义，对旧的进行任何有意义操作，都是报错。新变量名是数据的新所有者。在copy行为下，新旧二者同时存在，是两个独立的存在，两份独立数据，互不干扰，各自可独立修改。

但正常的逻辑，对于某一个数据源，都是会进行多次操作，可能是查看数据然后继续分支逻辑，可能是查看并修改数据。反正查看是非常频繁的事。如果数据只能move，那么应该是写不了正常的代码逻辑了。然后，就有了引用（指针）的概念，指针是一个普通的基本类型 usize ，根据操作系统不同，有不同大小，例如64位系统对于u64。所谓指针（引用），就是对应数据源的地址编号。

一般来说，copy/move行为发生，那就是统一认为在另一个内存地址得到了一份新数据。（实际上copy是这样的；变量名其实就是指针，move其实是数据地址不变，搞了一个新的变量名/指针）这样认为是为了减少心智负担，rust没有gc，确保数据源在被使用的上下文中切实存在，所有的引用可以切实在 上下文/周围 找到数据源。如果不做这种假设，move了几十次，存在几十个来源不同变量名的引用，虽然对应同一个地址的数据源，但非人类可读，可能几百行代码，已经分不清来源是谁了。

为了确保在无gc的情况下，能在附件上下文找到来源，就有生命周期的概念。如果是一个独立完整不依赖其他数据的数据源，它不需要生命周期，生命周期就是它生到它死。现在一个引用指向某个数据源，为了能切实找到对应数据，那么引用的生命长度是：引用产生到引用废弃/数据源死亡。引用产生一定在数据源产生之后，也必须消亡于数据源消失之前或同一时刻。（但是引用可以单独作为一个可变的存在usize，可以指向不同数据源，所以不一定绑死一个数据源的生命周期，但这只是可变mut的情况，rust默认不可变）

现在是多线程的情况：几乎所有基本数据都可以在线程之间移动。所谓多线程，和cpu的能力有关，现代多核cpu，能做通用计算，但每个单独cpu都是相对独立的，每个cpu都有处理能力，也都有自己的数据/缓存。没有绝对的主次，最早的线程就是一个cpu对应一个线程。普通程序都是运行在一个线程/主线程上，到了多线程代码部分，由于数据是相对隔离的，并且线程之间也是消亡时间不等的，有的早消亡，有的晚。直接将 数据源/所有权 抛给另一个线程，这叫做 send，对于原线程，抛出去的数据源，生命周期就结束了。

我们往往不需要复制，因为复杂数据的复制是耗时/浪费资源的，所以某个变量（不管是数据源还是引用）的引用在不同线程中共享（读取数据/同步数据）的能力，就叫sync。某个变量是sync，就是该变量的引用（usize）是可复制且可传播到不同线程的。
所以存在某个 T ，其引用 &T 是send，那么 T 是 sync。

