## “空”篇
编程语言的世界里，“空”是永远的问题，它永远在，又没有一个明确的归属。
如果“空”是单独定义的一类存在类型，那么任意类型都会有属于“空”的情况，但一个纯粹的“空”存在时，除非有其他足够的信息，否则“空”在此时是任意归属的，此时你可以非常容易的创造谬误逻辑。
如果“空”是无法单独存在的，只有那些能够空的类型会存在自己的类型为空的情况，即：“空”是带类型的。此时，任意一个“空”都有类型。存在任意一个“空”，我们都可以知道它的类型归属，写出谬误逻辑的可能减小了。

对于“空”的操作是不允许的。所以，golang提供了基础类型的默认值，这是方便了程序员，但也出现了一个问题，“空”是不存在，而基础类型的默认值一定是非空的，当其他角色获取数据时，不知道是默认值还是空。现实意义中，“空”一定是和默认值不等的，某些少数情况下二者可以互相替换。
golang既然为基础类型提供了默认值，那就确保了对基础类型一定是可以进行操作的；同时golang也提供了引用类型，引用类型也是同样的逻辑，尽量保证对空的操作是不出错的。对于slice、map等类型是类型明确的，某些方法调用时确实是可以这么操作；对于接口类型，为“空”时，任何方法调用都是不可能的。


## 接口篇
golang的接口是一种约束，约定有什么功能，能提供什么方法。
存在类型A，存在接口类型C，当某个A赋值给C时，C不为空，C为空的情况有且仅当定义C且不赋值的情况。
golang没有要求强制处理为空的情况，它默认尽力保证为空时也可运行，导致“类型B的空”向下传递到类型C，“类型C的空”明确定义为“C未赋值的情况”，所以空B赋值给C是“非空的C”，空的陷阱在不同类型赋值时，就埋下了.

