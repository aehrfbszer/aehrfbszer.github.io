# 不得不说，golang的泛型有点丑，可读性就这样了，表现力问题更严重
golang 最终是选择了[ T ] 样式的泛型，和<T>相比，可读性差了一点，但也问题不大。

但是，golang类型签名多一点就非常难看了，看看别人rust，where子句的表现力多强，golang还要另外定义一个接口来优化阅读体验。
在泛型方面，表现力是真的不可或缺的东西，golang的表现力我感觉问题更大。
根据golang的哲学，怎么看也不可能为泛型加什么新关键字，加什么新能力。
那么泛型在golang中的作用，百分之一亿是不可能会有大的发展，使用的广泛度一定被局限在一个小范围内。

golang泛型表现力差，所以会有优点，那就是泛型不会复杂；缺点同样是表现力差，那就不会广泛应用。
总之golang加了泛型不会变复杂，那倒是符合它的语言哲学了。

# 泛型即一种形式，和接口一样的形式
在 [nil篇](nil.md) ,里面描述了接口就是一种纯粹的“形式”，泛型同样是“形式”，具体的约束在泛型中成了“类型”。

“形式”是虚的，首先“类型”是形式的，他是真实数据的抽象/指代。

所有的“形式”无论如何都是来源于“本质”，而在代码世界里，“本质”只有真实的“数据”。

你定义一个int，实际上就是表现了一个“形式”，它不应该有任何作用，除非你赋值了，比如 var a int = 1 。但是golang给了所有类型一个默认值，所以在这个方面golang混淆了“形式”与“本质”。

“函数”其实也是一种形式。首先：我们可以认为函数只是对“输入类型”与“输出类型”的一种约定，整体形式上就是 “输入”->“输出”的形式，其次输入输出是虚的，不是真实的数据，是对真实数据的指代，这个“指代”就算“数据类型”。

但是在函数体的内部，往往会有真实数据写在其中，特别是函数调用时，它就是对真实数据的操作，**所以“函数体（函数实现）”是拥有“本质”的，“函数签名”是纯粹的“形式”**。

那么golang的“接口”，只是“函数签名”的组合形式，即“接口”是形式的。

golang的“泛型”更简单，只是“类型（包含接口）”的组合，是形式的。

我一直在区分“形式”与“本质”，看起来“形式”是没多大用处的，其实恰恰相反，“形式”可以说是“最重要”的。“本质”是一切真实的操作，对于“本质”，我们将其“形式化”了。“形式化”就是对“本质”的手段、途径、约束、认知。

对“本质”的认知、区分等就是形式化，我们对其能进行操作，也正因有且仅有“形式化”。

题外话：函数式编程，岂不就是编程“形式化”的巅峰了。



