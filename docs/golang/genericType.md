# 不得不说，golang的泛型有点丑，可读性就这样了，表现力问题更严重
golang 最终是选择了[ T ] 样式的泛型，和<T>相比，可读性差了一点，但也问题不大。

但是，golang类型签名多一点就非常难看了，看看别人rust，where子句的表现力多强，golang还要另外定义一个接口来优化阅读体验。
在泛型方面，表现力是真的不可或缺的东西，golang的表现力我感觉问题更大。
根据golang的哲学，怎么看也不可能为泛型加什么新关键字，加什么新能力。
那么泛型在golang中的作用，百分之一亿是不可能会有大的发展，使用的广泛度一定被局限在一个小范围内。

golang泛型表现力差，所以会有优点，那就是泛型不会复杂；缺点同样是表现力差，那就不会广泛应用。
总之golang加了泛型不会变复杂，那倒是符合它的语言哲学了。

# 泛型即一种形式，和接口一样的形式
在 [nil篇](nil.md) ,里面描述了接口就是一种纯粹的“形式”，泛型同样是“形式”，具体的约束在泛型中成了“类型”。

“形式”是虚的，首先“类型”是形式的，他是真实数据的抽象/指代。

所有的“形式”无论如何都是来源于“本质”，而在代码世界里，“本质”只有真实的“数据”。

你定义一个int，实际上就是表现了一个“形式”，它不应该有任何作用，除非你赋值了，比如 var a int = 1 。但是golang给了所有类型一个默认值，所以在这个方面golang混淆了“形式”与“本质”。

“函数”其实也是一种形式。首先：我们可以认为函数只是对“输入类型”与“输出类型”的一种约定，整体形式上就是 “输入”->“输出”的形式，其次输入输出是虚的，不是真实的数据，是对真实数据的指代，这个“指代”就算“数据类型”。

但是在函数体的内部，往往会有真实数据写在其中，特别是函数调用时，它就是对真实数据的操作，**所以“函数体（函数实现）”是拥有“本质”的，“函数签名”是纯粹的“形式”**。

那么golang的“接口”，只是“函数签名”的组合形式，即“接口”是形式的。

golang的“泛型”更简单，只是“类型（包含接口）”的组合，是形式的。

我一直在区分“形式”与“本质”，看起来“形式”是没多大用处的，其实恰恰相反，“形式”可以说是“最重要”的。“本质”是一切真实的操作，对于“本质”，我们将其“形式化”了。“形式化”就是对“本质”的手段、途径、约束、认知。

对“本质”的认知、区分等就是形式化，我们对其能进行操作，也正因有且仅有“形式化”。

## 泛型是类型的形式化，如果类型（包括接口）是“一阶形式”，泛型就是基于“一阶形式”的“二阶形式”
泛型是什么，是建立在类型基础上的，对类型进行抽象，所以当泛型这一概念下：最基本的元素就是“类型”，在泛型语境下，“类型”属于“本质”。
```golang
type MyInt int
```
此处的MyInt是int的别名，它们不是同一层级的，int是真实的“本质”，MyInt是虚假的别名“形式”。

```golang
type AInt int
```
此处是定义了一个新类型AInt，与int是同一层级，都属于“本质”

```golang
interface {
	~[]byte  // the underlying type of []byte is itself
	~MyInt   // illegal: the underlying type of MyInt is not MyInt
	~error   // illegal: error is an interface
}
```
这样，就可以理解了，~T中的T要求是只能为“本质”，MyInt是别名、是“形式”，error是方法签名的集合、是“形式”。
~T本身就是一种形式，即允许底层类型为T的所有类型别名。
泛型显然在泛型语境下，是“形式”，只有实例化了泛型，才称为泛型语境下的“本质”-即某个类型。
定义泛型接口时，接口内的内容并不要求是“本质”（即类型），只要是形式就可以了。